## synchronized 的奇门遁甲术

在前面的篇当中，简单的从为了解决悲观、乐观锁一路溜到了CPU层面的 LOCK 标记位，那么这篇就应该开始了解了解 Java 并发锁机制当中的头牌老大哥 synchronized 了，在开始本篇之前，我觉得还是需要回顾温习一下前面两篇章的核心内容和思路，在此基础之上引出今天要谈论的点。

首先开篇笔者是以 ***人有悲欢离合、月有阴晴圆缺*** 的乐观悲观锁为开篇的，从最终的数据源 SQL 为切入点，梳理了一下 SQL 当中为了解决并发而提供的一套悲观锁(排它锁)以及从设计层面实现的一个根据版本比较锁(乐观锁)，在此基础之上又讨论了一下 Java 当中的关键字 volatile ，在此基础之上研究了一下在并发编程当中，对于不同的线程之间独有的工作空间而导致的数据不一致问题，从源代码到汇编指令层面研究了 volatile 关键字所具有的特性，并讲清楚了 x86 CPU 指令集当中的 LOCK 指令，是如何在发出 LOCK# 的信号前提下将缓存行数据锁定，在保证其他 CPU 不能修改和读取数据的前提下进行独占修改，从而在修改完成之后，其他 CPU 在进行变量副本比对是否有命中缓存行从而失效，实现不同线程内部的数据同步更新。当然也提到过关于 Doug Lea 在 LinkedTransferQueue 当中关于 volatile 修饰的变量通过追加64位字节进行了缓存行的优化。

虽然对于 volatile 而言，很好的可以通过 **内存屏障** 保证了有序性以及 **LOCK#信息** 保证了可见性，但还是无法解决**原子性**的问题。

ok，谈完了上面的回顾，接下来就回到正题，一起来研究一下 synchronized 有趣特性吧。

### synchronized 的奇术

