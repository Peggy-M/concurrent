## 并发的底层实现

Java 的代码最终是由 Jvm 解释执行的，因此对=Java 的并发机制而言都是依赖与 Jvm 的实现以及 CPU 的元语指令集。首先我们先看一下一个 Java 程序代码从诞生到运行的整个流程。

~~~shell
Java源码 → 字节码 → 解释器/JIT → 汇编码 → 机器码 → CPU执行
                   ↑
               运行时优化
~~~

我们知道的是对于计算机，无论是 C 、Python、TS 都是无法被计算机直接识别执行的，因为对于计算机而言底层唯一能识别由 CPU 执行的只有机器码也就由 0 与 1 组成的二进制编码，那为什么 Java 的一些并发执行都最终都会调用本地的 Native 方法，而不直接使用 Java 去控制 CPU 的并发呢 ？首先这个主要是由于 JVM 的底层实现机制有关。

首先，对于并发就涉及到了对 CPU 调度的控制，而关于 CPU 的线程的调度，锁机制，以及内存屏障和原子性操作都是需要 CPU 的原语支持，这些控制都必须要求直接方法操作系统以及硬件层，需要进行用户态和内核态之间的相互切换，而内核之间的切换只能调用 C/C++ 层面的操作系统函数

另一方，由于 JVM 为了在某一些方面的特性(跨平台、安全沙箱、垃圾自动回收)做出的牺牲和让步，JVM 屏蔽了对底层系统的直接访问

还有就是 HotSpot JVM 的底层都是使用 C++ 实现的，所有有关操作系统的交互底层机制 (如 `pthread`、Windows thread API) 就需要用 C++ 交互

### volatile 的大招是什么

#### 线程之间的可见性

在了解 volatile 之前，我先看看 volatile 的基本用法，从用法开始我们再去研究其底层的具体实现。

~~~ java
public class VolatileVisibilityDemo {

    // 共享变量，测试时不加 volatile 和加 volatile 的区别
    private static volatile boolean running = true;

    public static void main(String[] args) throws InterruptedException {
        // 线程1：读取 running 变量
        Thread readerThread = new Thread(() -> {
            while (running) { // 如果 running 不是 volatile，可能看不到主线程的修改！
                // 空循环，模拟任务
            }
            System.out.println("ReaderThread: running 已变为 false，退出循环");
        });

        // 线程2：修改 running 变量
        Thread writerThread = new Thread(() -> {
            try {
                Thread.sleep(1000); // 等待1秒，确保 readerThread 已经启动
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            running = false; // 修改 running
            System.out.println("WriterThread: 已设置 running = false");
        });

        readerThread.start();
        writerThread.start();

        readerThread.join();
        writerThread.join();
    }
}
~~~

~~~ shell
ReaderThread: running 已变为 false，退出循环
WriterThread: 已设置 running = false
~~~

从上面的案例可以看到，当 reader 线程开始执行，由于变量 running 为 true 所有程序一直处于空转的状态，而当 writer 线程开始执行的时候修改了 running 状态为 false ，由于使用了 volatile 所以这个修改对于线程 reader 线程来说是可见的，因此就会停止循环结束 reader  走完剩下流程直到线程任务的结束。

#### 指令重排序

由于编码最终被编译之后最终是形成了机器码，而机器码最终可能会由于。指令重排序（Instruction Reordering）是 **CPU 或 JVM 为了提高程序运行效率**，在 **不影响单线程执行结果** 的前提下，对指令的执行顺序进行优化的行为，这种指令优化本身是为了提升程序执行的效率，但有可能会出现一些我们无法预知的问题。

这里举一个简单的案例

~~~ java
public class Singleton {
    private static volatile Singleton instance; // 必须加 volatile

    public static Singleton getInstance() {
        if (instance == null) {                     // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {              // 第二次检查
                    instance = new Singleton();      // 不加 volatile 可能导致指令重排序问题
                }
            }
        }
        return instance;
    }
}
~~~



~~~ java
// 线程A执行初始化操作
configOptions = new HashMap();      // 1. 分配内存
configText = readConfigFile();      // 2. 读取配置
processConfigOptions();             // 3. 处理配置
initialized = true;                 // 4. 标记初始化完成（可能被重排序提前执行！）
~~~

如果 `initialized` **没有 `volatile` 修饰**，JVM 或 CPU **可能会对指令进行重排序**，比如：此时，`initialized = true` **被提前执行**，但 `configOptions` 和 `configText` 还未初始化完成！

~~~ shell
initialized = true;               // 4. 先执行！（危险！）
configOptions = new HashMap();    // 1. 后执行
configText = readConfigFile();    // 2. 
processConfigOptions();           // 3. 
~~~







#### 能否保证原子性

我们这里再看一个案例，使用 volatile 是否可以控制线程的原子性？

~~~ java
public class VolatileExample {

    private volatile int  balance = 100;

    public void withdraw(int amount) {
        if (balance >= amount) {
            // #1
            try {
                // 模拟业务处理耗时
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            balance -= amount;
            System.out.println(Thread.currentThread().getName() + " 取款成功，余额: " + balance);
        } else {
            System.out.println(Thread.currentThread().getName() + " 余额不足");
        }

    }
}
~~~

~~~ java
@Test
public void testVolatileExample() throws InterruptedException {
    VolatileExample account = new VolatileExample();
    List<Thread> threads = new ArrayList<>();

    // 创建5个线程同时取款
    for (int i = 0; i < 5; i++) {
        Thread thread = new Thread(() -> account.withdraw(30), "线程" + i);
        thread.start();
        threads.add(thread);
    }

    for (Thread thread : threads) {
        thread.join();
    }
}
~~~

~~~ shell
线程1 取款成功，余额: 40
线程0 取款成功，余额: -50
线程3 取款成功，余额: 10
线程4 取款成功，余额: 40
线程2 取款成功，余额: -20
~~~

可以从运行的结果看到，由于并能保证原子性。当程序执行到 #1 位置的时候，由于并发执行，当每个线程都拿到初始数据之后，在执行  balance -= amount; 的时候，该命令并非是一个原子性的操作，导致每一个线程从内存读取到数据和写入数据的时机可能是同一时刻，导致与预期结果不同。

| **时间** | **线程 A**           | **线程 B**           | **`balance` 的值** |
| :------- | :------------------- | :------------------- | :----------------- |
| t1       | 读取 `balance = 100` | -                    | 100                |
| t2       | -                    | 读取 `balance = 100` | 100                |
| t3       | 计算 `100 - 50 = 50` | -                    | 100                |
| t4       | -                    | 计算 `100 - 50 = 50` | 100                |
| t5       | 写入 `balance = 50`  | -                    | 50                 |
| t6       | -                    | 写入 `balance = 50`  | 50                 |

通过上面的案例，其实可以看到 volatile 的特性就是将本身，线程之间隔离的变量变得修改可见。那么这个原理到底是什么呢？在这个研究这个基础之上，我们可能需要补充一点 Jvm 内存模型方面的知识，以便于我们更好的理解线程隔离以及 volatile 可见性的两种特性。





### 加餐一点并发模型

