## 线程的状态

线程得状态其实是分两种得，一种是基于 Java 层面，另一个是操作系统层面，对于 java 而言线程的状态是由 JVM 进行管理的，JVM 会利用操作系统提供的线程调度机制来执行这些线程。操作系统会提供更底层的线程状态和调度，而 Java 对线程状态的管理则是建立在操作系统调度基础上的。

- 线程刚被创建，但尚未启动，此时对于操作系统而言还并未开始调用，所以并不消耗操作系统的资源，操作系统中尚未分配 CPU 或资源给此线程。
- 当前调用线程的start方法启动线程之后，线程处于 **RUNNABLE** 状态，此时对于操作系统而言可能是处于 **就绪队列**等待操作系统分配 CPU 时间片，或者已经在 CPU 上执行。对于操作系统来说，线程被分配了 CPU 时间，处于 **RUNNING** 状态，或者线程处于 **就绪** 状态，具体取决于 CPU 是否为其分配时间片。
- 在线程运行当中很可能会因为线程之间的同步机制如 synchronized 同步锁，造成线程处于 **BLOCKED**  阻塞状态，等待锁资源的释放，对于操作系统而言，操作系统的线程调度通常没有直接感知到“锁”的概念，操作系统会将线程置于 **WAITING** 状态或 **BLOCKED** 状态，但通常它将等待其他资源的释放，直到线程能够继续执行。
- 线程调用了 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()` 等方法时，进入 **WAITING** 状态，此时线程等待某些条件（如其他线程的通知）。操作系统会将线程挂起，处于 **SLEEP** 状态，直到条件满足（例如信号、事件或其他线程的通知）。在 Linux 中，线程会处于 **S**（Sleeping）或 **D**（Uninterruptible Sleep）状态。

- 线程进入 **TIMED_WAITING** 状态，通常是因为调用了 `Thread.sleep(millis)`、`Object.wait(long millis)`、`Thread.join(long millis)` 等方法，并且线程需要等待一段特定时间。线程在操作系统中通常处于 **SLEEP** 状态，操作系统会等待指定的时间或者直到某些条件满足，才能将线程从 **SLEEP** 状态唤醒。
- **Java**：线程执行完毕，进入 **TERMINATED** 状态。此时线程已经退出，不再运行。操作系统将线程的状态标记为 **ZOMBIE** 或 **DEAD**。当线程执行完成后，操作系统会清理资源并回收线程。